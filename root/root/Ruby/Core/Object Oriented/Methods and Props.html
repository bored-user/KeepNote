<html>
  
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../../../../style.css">
    <base target="_parent">
  </head>
  
  <body>
     <h1>Methods and Props</h1>

    <p>Properties, in Ruby, are called <i>attributes</i>.</p>
    <p>And they're basically the same as methods. The only difference is that
      an attribute is a method that returns its instance variables values.</p>
    <p>What I mean by that is: since Ruby does not require brackets on function
      calls, when someone uses <code>my_class.some_attr</code>, Ruby is executing
      a method named <code>some_attr</code> from the <code>my_class</code> object.</p>
    <p>The same thing happens when someone tries to set an attribute: <code>my_class.some_attr = ‘some_value’</code> actually
      means that you're calling a function named <code>some_attr=</code> (Ruby
      automatically removes the space after "attr") from the <code>my_class</code> object.</p>
    <p>That's why, in order to have access to the attributes of a class outside
      said class, one needs to create (basically) getters and setters methods:</p>
    <section
    class="include-note" data-note-id="4dabDu3lGVrY" data-box-size="full">&nbsp;</section>
      <p>To solve that, one needs to create said getters and setters:</p>
      <section
      class="include-note" data-note-id="fYEO9EDnJC78" data-box-size="full">&nbsp;</section>
        <p>But having to write two methods per attribute is a little too much, isn't
          it? Think about the Big O Notation of this. It would be <code>n*2</code>,
          which is a lot.</p>
        <p>That's because Ruby has the <a href="attr%20methods.html"><code>attr</code> methods</a>!</p>
  </body>

</html>